# -*- coding: utf-8 -*-
"""Gamegos Employee Entry Logs.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ABIILAfeE7hSyVK0dty8QNRKWeQK1Fzy
"""

import pandas as pd
import re
from google.colab import files
from IPython.display import display

# Step 1: Upload the file
uploaded = files.upload()

# Assuming only one file is uploaded, get its filename
file_name = list(uploaded.keys())[0]

print(file_name)

# Step 2: Load and process the Excel file
df = pd.read_excel(file_name)

# Filter rows where the first column starts with a time pattern (HH:MM:SS)
time_pattern = r"^\d{2}:\d{2}:\d{2}"
filtered_df = df[df.iloc[:, 0].astype(str).str.match(time_pattern)]

# Drop columns that contain only NaN values
filtered_df = filtered_df.dropna(axis=1, how='all')

# Rename columns
filtered_df.columns = ['Time', 'Event', 'AccessStatus', 'CardID', 'EmployeeName', 'CompanyName']

# Keep only the 'Time', 'Event', and 'EmployeeName' columns
filtered_df = filtered_df[['Time', 'Event', 'EmployeeName']]

# Convert 'Time' column to datetime format for time calculations
filtered_df['Time'] = pd.to_datetime(filtered_df['Time'], format='%H:%M:%S')

# Identify entry and exit events
filtered_df['EntryExit'] = filtered_df['Event'].apply(lambda x: 'Entry' if 'GIRIS' in x else ('Exit' if 'CIKIS' in x else None))

# Drop rows where EntryExit is None (in case of irrelevant rows)
filtered_df = filtered_df.dropna(subset=['EntryExit'])

# Sort by EmployeeName and Time
filtered_df = filtered_df.sort_values(by=['EmployeeName', 'Time']).reset_index(drop=True)

# Initialize lists to store the results
results = []

# Group by each employee and calculate the durations
for employee, group in filtered_df.groupby('EmployeeName'):
    group = group.reset_index(drop=True)

    # Get the first entry and last exit times
    first_entry = group.loc[group['EntryExit'] == 'Entry', 'Time'].min()
    last_exit = group.loc[group['EntryExit'] == 'Exit', 'Time'].max()

    # Initialize durations and long break counter
    inside_duration = pd.Timedelta(0)
    outside_duration = pd.Timedelta(0)
    long_break_count = 0

    # Iterate over the group to calculate time intervals
    for i in range(len(group) - 1):
        if group.loc[i, 'EntryExit'] == 'Entry' and group.loc[i + 1, 'EntryExit'] == 'Exit':
            # Calculate inside duration
            inside_duration += group.loc[i + 1, 'Time'] - group.loc[i, 'Time']
        elif group.loc[i, 'EntryExit'] == 'Exit' and group.loc[i + 1, 'EntryExit'] == 'Entry':
            # Calculate outside duration
            current_outside_duration = group.loc[i + 1, 'Time'] - group.loc[i, 'Time']
            outside_duration += current_outside_duration

            # Check if outside duration is longer than 15 minutes (900 seconds)
            if current_outside_duration > pd.Timedelta(minutes=15):
                long_break_count += 1

    # Calculate total time
    total_duration = inside_duration + outside_duration

    # Store results
    results.append({
        'Employee Name': employee,
        'First Entry Time': first_entry.time() if pd.notna(first_entry) else None,
        'Last Exit Time': last_exit.time() if pd.notna(last_exit) else None,
        'Total Inside Duration': f"{int(inside_duration.total_seconds() // 3600):02}:{int((inside_duration.total_seconds() % 3600) // 60):02}",
        'Total Outside Duration': f"{int(outside_duration.total_seconds() // 3600):02}:{int((outside_duration.total_seconds() % 3600) // 60):02}",
        'Sum of Inside and Outside Durations': f"{int(total_duration.total_seconds() // 3600):02}:{int((total_duration.total_seconds() % 3600) // 60):02}",
        'Long Breaks Count': long_break_count
    })

# Step 3: Convert results to a DataFrame and display
summary_df = pd.DataFrame(results)

# Condition 1: First Entry Time later than 10:30
def red_late_entry(val):
    if pd.notnull(val) and val > pd.Timestamp('10:30').time():
        return 'color: red'
    return 'color: black'

# Condition 2: Total Inside Duration shorter than 8 hours
def red_short_inside(val):
    if pd.notnull(val):
        hours, minutes = map(int, val.split(':'))
        duration = pd.Timedelta(hours=hours, minutes=minutes)
        if duration < pd.Timedelta(hours=8):
            return 'color: red'
    return 'color: black'

# Condition 3: Sum of Inside and Outside Durations shorter than 9 hours
def red_short_total(val):
    if pd.notnull(val):
        hours, minutes = map(int, val.split(':'))
        duration = pd.Timedelta(hours=hours, minutes=minutes)
        if duration < pd.Timedelta(hours=9):
            return 'color: red'
    return 'color: black'

# Condition 4: Long Breaks Count larger than 1
def red_long_breaks(val):
    if pd.notnull(val) and val > 1:
        return 'color: red'
    return 'color: black'

# Apply the style to each relevant column based on the conditions
styled_df = summary_df.style.map(red_late_entry, subset=['First Entry Time']) \
                             .map(red_short_inside, subset=['Total Inside Duration']) \
                             .map(red_short_total, subset=['Sum of Inside and Outside Durations']) \
                             .map(red_long_breaks, subset=['Long Breaks Count'])

# Display the styled DataFrame
display(styled_df)

from google.colab import files

# Save the processed DataFrame as an Excel file
output_filename = "processed_summary.xlsx"
styled_df.to_excel(output_filename, index=False)

# Download the file
files.download(output_filename)